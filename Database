package application;

import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

public class Database {
	private static final String DATABASE_URL = "jdbc:sqlite:test.db";
    private static List<ScheduledTransaction> scheduledTransactions = new ArrayList<>();


    public static void main(String[] args) {
    	createDatabase();
    }
    
    public static void clearDatabase() {
        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             Statement stmt = conn.createStatement()) {

            // Clear data from tables
            String deleteFromAccounts = "DELETE FROM Accounts;";
            String deleteFromTransactionTypes = "DELETE FROM transaction_types;";
            String deleteFromTransactions = "DELETE FROM transactions;";
            String deleteFromScheduledTransactions = "DELETE FROM scheduled_transactions;";

            stmt.executeUpdate(deleteFromTransactions);
            stmt.executeUpdate(deleteFromTransactionTypes);
            stmt.executeUpdate(deleteFromAccounts);
            stmt.executeUpdate(deleteFromScheduledTransactions);

            System.out.println("All data cleared from the database.");

        } catch (SQLException e) {
            System.err.println("Error clearing the database: " + e.getMessage());
        }
    }
    
    public static void createDatabase() {
        try {
            Class.forName("org.sqlite.JDBC");

            try (Connection connection = DriverManager.getConnection(DATABASE_URL);
                 Statement stmt = connection.createStatement()) {

                // Create Accounts table
                String createAccountsTable = "CREATE TABLE IF NOT EXISTS Accounts (" +
                        "ID INTEGER PRIMARY KEY AUTOINCREMENT, " +
                        "AccountName TEXT NOT NULL, " +
                        "OpeningDate TEXT NOT NULL, " +
                        "OpeningBalance REAL NOT NULL);";

                // Create transaction_types table
                String createTransactionTypesTable = "CREATE TABLE IF NOT EXISTS transaction_types (" +
                        "type_name TEXT PRIMARY KEY);";

                // Create transactions table with transaction_type column
                String createTransactionsTable = "CREATE TABLE IF NOT EXISTS transactions (" +
                	    "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                	    "account_name TEXT NOT NULL, " +
                	    "transaction_type TEXT NOT NULL, " +
                	    "transaction_date TEXT NOT NULL, " +
                	    "description TEXT, " +
                	    "payment_amount REAL, " +
                	    "deposit_amount REAL, " +
                	    "FOREIGN KEY(account_name) REFERENCES Accounts(AccountName), " +
                	    "FOREIGN KEY(transaction_type) REFERENCES transaction_types(type_name));";


                // Execute SQL statements in order
                stmt.executeUpdate(createAccountsTable);
                stmt.executeUpdate(createTransactionTypesTable);
                stmt.executeUpdate(createTransactionsTable);

            }
        } catch (ClassNotFoundException e) {
            System.err.println("SQLite JDBC Driver not found.");
        } catch (SQLException e) {
            System.err.println("SQL Exception: " + e.getMessage());
        }
    }
    
    public static List<Transaction> getAllTransactions() {
        List<Transaction> transactions = new ArrayList<>();
        String sql = "SELECT * FROM transactions ORDER BY transaction_date DESC";

        try (Connection conn =  DriverManager.getConnection(DATABASE_URL);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                transactions.add(new Transaction(
                        rs.getString("account_name"),
                        rs.getString("transaction_type"),
                        LocalDate.parse(rs.getString("transaction_date")),
                        rs.getString("description"),
                        rs.getDouble("payment_amount"),
                        rs.getDouble("deposit_amount")
                ));
            }

        } catch (SQLException e) {
            System.err.println("Error fetching transactions: " + e.getMessage());
        }
        return transactions;
    }
    
//    public static void ensureScheduledTransactionsTableExists() {
//        String sql = "CREATE TABLE IF NOT EXISTS scheduled_transactions (" +
//                     "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
//                     "schedule_name TEXT NOT NULL, " +
//                     "account_name TEXT NOT NULL, " +
//                     "transaction_type TEXT NOT NULL, " +
//                     "frequency TEXT NOT NULL, " +
//                     "due_date INTEGER NOT NULL, " +
//                     "payment_amount REAL NOT NULL, " +
//                     "FOREIGN KEY (account_name) REFERENCES Accounts(AccountName), " +
//                     "FOREIGN KEY (transaction_type) REFERENCES transaction_types(type_name)" +
//                     ")";
//
//        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
//             Statement stmt = conn.createStatement()) {
//
//            stmt.executeUpdate(sql); // Create the table if it doesn't exist
//            System.out.println("Scheduled Transactions table ensured.");
//
//        } catch (SQLException e) {
//            System.err.println("Error ensuring scheduled_transactions table exists: " + e.getMessage());
//        }
//    }
    
    public static void saveTransactionType(String transactionType) {
        String sql = "INSERT OR IGNORE INTO transaction_types (type_name) VALUES (?)";

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, transactionType);
            pstmt.executeUpdate();

        } catch (SQLException e) {
            System.err.println("Error saving transaction type: " + e.getMessage());
        }
    }
    
    public static List<String> getAllTransactionTypes() {
        List<String> transactionTypes = new ArrayList<>();
        String sql = "SELECT type_name FROM transaction_types";

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                transactionTypes.add(rs.getString("type_name"));
            }

        } catch (SQLException e) {
            System.err.println("Error fetching transaction types: " + e.getMessage());
        }
        return transactionTypes;
    }
    
    
    
    public static ObservableList<ScheduledTransaction> getAllScheduledTransactions() {
        ObservableList<ScheduledTransaction> scheduledTransactionsList = FXCollections.observableArrayList();
        String sql = "SELECT schedule_name, account_name, transaction_type, frequency, due_date, payment_amount " +
                     "FROM scheduled_transactions " +
                     "ORDER BY due_date ASC"; // Adjust sorting if needed

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {

            while (rs.next()) {
                String scheduleName = rs.getString("schedule_name");
                String accountName = rs.getString("account_name");
                String transactionType = rs.getString("transaction_type");
                String frequency = rs.getString("frequency");
                int dueDate = rs.getInt("due_date");
                double paymentAmount = rs.getDouble("payment_amount");

                // Create the ScheduledTransaction object with the retrieved data
                ScheduledTransaction scheduledTransaction = new ScheduledTransaction(
                    scheduleName,
                    accountName,
                    transactionType,
                    frequency,
                    dueDate,
                    paymentAmount
                );

                scheduledTransactionsList.add(scheduledTransaction);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return scheduledTransactionsList;
    }

    public static ObservableList<Transaction> searchTransactionsByDescription(String substring) {
        ObservableList<Transaction> results = FXCollections.observableArrayList();
        String sql = "SELECT * FROM transactions WHERE description LIKE ?";

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, "%" + substring + "%");
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                Transaction transaction = new Transaction(
                    rs.getString("account_name"),
                    rs.getString("transaction_type"),
                    LocalDate.parse(rs.getString("transaction_date")),
                    rs.getString("description"),
                    rs.getDouble("payment_amount"),
                    rs.getDouble("deposit_amount")
                );
                results.add(transaction);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return results;
    }


    
    
    
    public static void saveAccount(Account account) {
        String sql = "INSERT INTO accounts (name, opening_date, opening_balance) VALUES (?, ?, ?)";
        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, account.getAccountName());
            pstmt.setDate(2, Date.valueOf(account.getOpeningDate())); // Get LocalDate from SimpleObjectProperty
            pstmt.setDouble(3, account.getOpeningBalance()); // Get double value from SimpleDoubleProperty
            pstmt.executeUpdate();
            System.out.println("Account added successfully: " + account.getAccountName());
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static void addAccount(Account account) {
        String sql = "INSERT INTO Accounts(AccountName, OpeningDate, OpeningBalance) VALUES(?, ?, ?)";

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, account.getAccountName());
            pstmt.setString(2, account.getOpeningDate().toString());
            pstmt.setDouble(3, account.getOpeningBalance());
            pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static ObservableList<Account> getAllAccounts() {
        ObservableList<Account> accounts = FXCollections.observableArrayList();
        String sql = "SELECT AccountName, OpeningDate, OpeningBalance FROM Accounts ORDER BY OpeningDate DESC";

        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                String name = rs.getString("AccountName");
                LocalDate date = LocalDate.parse(rs.getString("OpeningDate"));
                double balance = rs.getDouble("OpeningBalance");

                accounts.add(new Account(name, date, balance));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return accounts;
    }
    // Method to save a transaction to the database
    public static boolean saveTransaction(String accountName, String transactionType, LocalDate date, 
                                          String description, double paymentAmount, double depositAmount) {
    	String sql = "INSERT INTO transactions(account_name, transaction_type, transaction_date, description, payment_amount, deposit_amount) " +
                "VALUES(?, ?, ?, ?, ?, ?)";


        try (Connection conn = DriverManager.getConnection(DATABASE_URL);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, accountName);
            pstmt.setString(2, transactionType);
            pstmt.setString(3, date.toString());
            pstmt.setString(4, description);
            pstmt.setDouble(5, paymentAmount);
            pstmt.setDouble(6, depositAmount);
            pstmt.executeUpdate();
            return true;
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }
    
    public static boolean saveScheduledTransaction(String scheduleName, String accountName, String transactionType,
        String frequency, int dueDate, double paymentAmount) {
		//ensureScheduledTransactionsTableExists(); // Ensure the table exists
		String sql = "INSERT INTO scheduled_transactions (schedule_name, account_name, transaction_type, frequency, due_date, payment_amount) " +
		"VALUES (?, ?, ?, ?, ?, ?)";
		
		try (Connection conn = DriverManager.getConnection(DATABASE_URL);
		PreparedStatement pstmt = conn.prepareStatement(sql)) {
		
		pstmt.setString(1, scheduleName);
		pstmt.setString(2, accountName);
		pstmt.setString(3, transactionType);
		pstmt.setString(4, frequency);
		pstmt.setInt(5, dueDate);
		pstmt.setDouble(6, paymentAmount);
		
		pstmt.executeUpdate();
		
		System.out.println("Scheduled transaction saved successfully: " + scheduleName);
		return true;
		
		} catch (SQLException e) {
		System.err.println("Error saving scheduled transaction: " + e.getMessage());
		return false;
	}

}
}
